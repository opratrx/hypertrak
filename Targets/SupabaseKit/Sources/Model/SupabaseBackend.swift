//
//  SupabaseBackend.swift
//  SupabaseKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/databasekit
//

import AnalyticsKit
import AuthenticationServices
import Foundation
import SharedKit
import Supabase
import SwiftUI

/// Enum representing authentication states.
public enum AuthState {
	case signedOut
	case signedIn
}

/// Represents data structure for a post.
struct PostData: Codable, Identifiable, Equatable {
	let id: Int
	let title: String
	let content: String
	let creationDate: Date
	let postUserID: UUID  // post author id
}

@MainActor
public class DB: ObservableObject {

	/// Variable reference to access Supabase.
	///
	/// Don't access it directly, to fetch data, but rather do so via
	/// dedicated functions such as the `fetchPosts()` example function below.
	internal let _db: SupabaseClient

	/// See DatabaseExampleView.swift
	@Published var posts: [PostData] = []

	/// SupabaseAuth user state, nil if not logged in
	@Published public var currentUser: User? = nil

	/// SupabaseAuth State (use this to check auth state, updates with currentUser)
	@Published public var authState: AuthState = .signedOut

	/// For Supabase to keep track of the Auth State (see AuthGeneral.swift)
	internal var authStateHandler: AuthStateChangeListenerRegistration?

	/// For Sign in With Apple (Specifically, for account deletion. Is set when the user signs in with Apple)
	internal var appleIDCredential: ASAuthorizationAppleIDCredential?

	/// For Sign in With Apple (see SignInWithApple.siwft)
	internal var currentNonce: String?

	///- Parameter onAuthStateChange: Additional closure to pass to the AuthState Listener.
	/// We use this to set all the different providers to use the same, supabase-issued user ID to identify the user.
	public init(
		onAuthStateChange: @escaping (AuthChangeEvent, Session?) -> Void = { _, _ in }
	) {
		let supabaseURLString = try? getPlistEntry("SUPABASE_URL", in: "Supabase-Info")
		let apiKey = try? getPlistEntry("SUPABASE_KEY", in: "Supabase-Info")

		guard let apiKey, let supabaseURLString, let supabaseURL = URL(string: supabaseURLString) else {
			fatalError("ERROR Couldn't get SupabaseURL and API Keys in Supabase-Info.plist!")
		}

		_db = SupabaseClient(
			supabaseURL: supabaseURL,
			supabaseKey: apiKey
		)

		Task {
			await registerAuthStateListener(additionalHandler: onAuthStateChange)
		}
	}
}

//MARK: - DatabaseExampleView
extension DB {

	/// Fetches posts from the database asynchronously and sets them in the `posts` property.
	@MainActor
	public func fetchPosts() async {
		Analytics.capture(.info, id: "fetch_posts_called", source: .db)
		var newPostsData: [PostData] = []

		do {
			newPostsData = try await _db.from("posts").select().execute().value

			Analytics.capture(
				.success, id: "fetch_posts", longDescription: "Fetched \(newPostsData.count) posts from the db.",
				source: .db)

		} catch {
			Analytics.capture(
				.error, id: "fetch_posts", longDescription: "Error fetching posts: \(error)", source: .db)
			return
		}
		newPostsData.sort(by: { $0.creationDate > $1.creationDate })
		posts = newPostsData
	}

	/// Adds a post anonymously to the database.
	public func addPost(title: String, content: String) async -> Bool {
		Analytics.capture(.info, id: "add_post_called", source: .db)
		do {

			// If we just insert using the normal PostData, we will have to provide
			// it with an ID and a creationDate. If we don't pass them, the DB will automatically
			// assign the newly created post these values.
			// (If you have set up your DB to automatically set default values)
			struct PostDataWithoutIdAndDate: Encodable {
				let title: String
				let content: String
			}

			// Add a new post to the DB with provided values
			// and return the result.
			let createdPost: PostData =
				try await _db
				.from("posts")
				.insert(PostDataWithoutIdAndDate(title: title, content: content))
				.select()
				.single()
				.execute()
				.value

			Analytics.capture(
				.success, id: "add_post", longDescription: "User created post with ID: \(createdPost.id)",
				source: .db)
			return true
		} catch {
			Analytics.capture(
				.error, id: "add_post", longDescription: "Error during post creation: \(error)", source: .db)
			return false
		}
	}

	public func deletePost(id: Int) async {
		Analytics.capture(.info, id: "delete_post_called", longDescription: "PostID: \(id)", source: .db)
		do {
			try await _db.from("posts").delete().eq("id", value: id).execute()
			Analytics.capture(.success, id: "delete_post", longDescription: "PostID: \(id)", source: .db)
		} catch {
			Analytics.capture(
				.error, id: "delete_post",
				longDescription: "Error deleting post with ID: \(id): \(error.localizedDescription)", source: .db)
		}
	}
}
