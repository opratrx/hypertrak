//
//  Errors.swift
//  SupabaseKit (Generated by SwiftyLaunch 1.5.0)
//

import AnalyticsKit
import Foundation
import SharedKit

//MARK: - AuthKit Errors

/// Only user-facing errors are defined here, errors that users have no business to know about land in catch-all errors
public enum AuthKitError: Error {

	// Sign in with Apple Errors
	case defaultSignInWithAppleError

	// Sign Out Error
	case defaultSignOutError

	// no user is signed in (for operations that are relevant to the user - account deletion, rename, etc)
	case noUserSignedIn

	// sensitive operation requires re-authentication
	case reauthRequired

	// unhandled error
	case catchAllError

	// Note: AnalyticsID will only be used if AnalyticsKit is enabled
	var values: (notifContent: InAppNotificationContent, analyticsID: String) {
		switch self {
			case .defaultSignInWithAppleError:
				return (
					.init(title: "Couldn't Sign In", message: "Error Signing In with Apple"),
					"signin_with_apple_catchall"
				)
			case .noUserSignedIn:
				return (
					.init(title: "Couldn't Delete User", message: "No User is currently signed in"),
					"delete_noone_signed_in"
				)
			case .reauthRequired:
				return (
					.init(title: "Re-Authentication Required", message: "Please, re-authenticate"),
					"reauth_required"
				)
			case .defaultSignOutError:
				return (.init(title: "Error Signing Out", message: "Try again later."), "sign_out")
			case .catchAllError:
				return (.init(title: "Error Performing Operation", message: "Try again later"), "catchall")

		}
	}

	func sendToAnalytics(longDescription: String) {
		Analytics.capture(.error, id: self.values.analyticsID, longDescription: longDescription, source: .auth)
	}

	func showAsInAppNotification() {
		showInAppNotification(.error, content: self.values.notifContent, size: .compact)
	}
}

/// Will try the passed closure function and if an error occurs, it will show an error notification.
/// Fallback notification is shown if an error occurs but the error isnt an AuthKitError, meaning we dont have a specific error to show.
/// For that reason a fallback notification should be a vague error describing what has failed.
/// For example: Error signing in should say *What* has failed -> "Sign in Error" or "Error Signing In", and not something like "Operation Failed"
func tryFunctionOtherwiseShowInAppNotification(fallbackNotificationContent: InAppNotificationContent, function: () throws -> Void)
{
	do {
		try function()
	} catch {
		guard let error = error as? AuthKitError else {
			showInAppNotification(.error, content: fallbackNotificationContent, size: .compact)
			return
		}
		error.showAsInAppNotification()
	}
}

/// Will try the passed closure function and if an error occurs, it will show an error notification.
/// Fallback notification is shown if an error occurs but the error isnt an AuthKitError, meaning we dont have a specific error to show.
/// For that reason a fallback notification should be a vague error describing what has failed.
/// For example: Error signing in should say *What* has failed -> "Sign in Error" or "Error Signing In", and not something like "Operation Failed"
func tryFunctionOtherwiseShowInAppNotification(
	fallbackNotificationContent: InAppNotificationContent, function: () async throws -> Void
) async {
	do {
		try await function()
	} catch {
		guard let error = error as? AuthKitError else {
			showInAppNotification(.error, content: fallbackNotificationContent)
			return
		}
		error.showAsInAppNotification()
	}
}
